{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/neo4j-indexes",
    "result": {"data":{"markdownRemark":{"html":"<p>Just as with PostgreSQL and MongoDB, frequently having an index becomes very important to query performance for your \"hot paths\" for your database querying habits.</p>\n<p>Let's say a new facet of our app is that people can find celebrities born the same year they are. Your query would look something like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">MATCH (p:Person) WHERE p.born = 1967 RETURN p;</code></pre></div>\n<p>A fairly simple query but like we've seen before, this will look at every person on the graph to examine their birth year. Imagine you had all of IMDB's database; that query could wreck a system. Let's use EXPLAIN to see why.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">EXPLAIN MATCH (p:Person) WHERE p.born = 1967 RETURN p;</code></pre></div>\n<p>You'll see it gives you a pretty in-depth answer that it will scan all 133 persons and then narrow it down to 13. Let's throw an index on Person's born attribute.</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">CREATE INDEX FOR (p:Person) ON (p.born);\nEXPLAIN MATCH (p:Person) WHERE p.born = 1967 RETURN p;\nMATCH (p:Person) WHERE p.born = 1967 RETURN p;\n</code></pre></div>\n<p>Now you'll see it immediately can narrow it down. My computer saw a 6x increase in query speed.</p>\n<p><a href=\"https://neo4j.com/docs/cypher-manual/4.1/query-tuning/\">Neo4j has a great article on query planning</a> if you want to dig further into improving query performance.</p>\n<p>Lastly, sometimes it's useful to see all existing indexes. Try this:</p>\n<div class=\"gatsby-highlight\" data-language=\"cql\"><pre class=\"language-cql\"><code class=\"language-cql\">CALL db.indexes;</code></pre></div>","frontmatter":{"path":"/neo4j-indexes","title":"Indexes in Neo4j","order":"4E","section":"Graph","description":"Query performance in a graph database is just as important as it is in any database. Brian teaches you to profile Neo4j queries and how to tune them for performance with indexes."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5D","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}