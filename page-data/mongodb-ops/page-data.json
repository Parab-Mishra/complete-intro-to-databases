{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/mongodb-ops",
    "result": {"data":{"markdownRemark":{"html":"<p>I am not going to teach you how to run a MongoDB cluster in production. Chances are high you don't need to know how and chances are even higher that I wouldn't know how to teach you anyway!</p>\n<p>But before we move on to SQL I wanted to teach you a tiny bit about some of the concepts of how MongoDB servers get run in production so you can understand what's happening, understand what can go wrong, and make yourself a better developer</p>\n<h2 id=\"primaries-secondaries-and-replica-sets\" style=\"position:relative;\"><a href=\"#primaries-secondaries-and-replica-sets\" aria-label=\"primaries secondaries and replica sets permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primaries, Secondaries, and Replica Sets</h2>\n<p>A replica set is a set of MongoDB servers (all running the <code class=\"language-text\">mongod</code> process) that all have the same set of data on them. This is done so that if one of the servers goes down, there are other servers available to step up and continue running without downtime as well as making sure that if a server blows up that you're not losing data.</p>\n<p>The primary server is the server that can accept reads (queries that don't modify anything e.g. find) and writes (queries that do modify things e.g. deleteOne, insertMany, etc.). Because it is the only server that can accept writes, it is usually the server under the most load. There is only one primary server per replica set at a time. It always has the most up-to-date information, guaranteed. It is the source of truth.</p>\n<p>The secondary servers can only accept reads. All writes must go through the primary. However if you're just doing a read operation you can freely use the secondary. It does end up storing all the information from the primary eventually but it's key to note the MongoDB has <strong>eventual consistency</strong>. That means the secondaries may have a lag time between when you write to the primary and when it updates the secondary. Some times this is acceptable (like storing a social feed of pictures) and some times it's not (like storing banking transactions.) MongoDB does have the ability to set write priorities so you can make your app pause until it can guarantee that all secondaries have received the write.</p>\n<h2 id=\"arbiters-and-elections\" style=\"position:relative;\"><a href=\"#arbiters-and-elections\" aria-label=\"arbiters and elections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Arbiters and Elections</h2>\n<p>When a primary server goes down, your remaining MongoDB servers hold an election. I won't go into the whole process but through an algorithm the secondaries will decide on a new primary and resume from there. This is MongoDB's failover strategy.</p>\n<p>Sometimes it's necessary to have another vote in the election, like if you're only running one primary and one secondary. In these cases you'll have another server that will be an arbiter. An arbiter just votes, it doesn't store data and cannot become a primary. You'd do this so that elections don't become deadlocked. You don't always need arbiters if you have a sufficient amount of secondaries.</p>\n<h2 id=\"sharding\" style=\"position:relative;\"><a href=\"#sharding\" aria-label=\"sharding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sharding</h2>\n<p>Sometimes your data sets so large that it wouldn't be wise to store all of it on set of servers due to resources like RAM and CPU. In these cases it becomes necessary to shard your data. This adds a non-trivial amount of complexity to your app so I'd suggest great caution before jumping into sharding.</p>\n<p>For example let's say you're storing all the personal social media information for every person in your country. How would you shard that data across multiple replica sets? One could be tempted to say all users with last names A-M go to one set and N-Z go to another. But is that really 50/50? No, and it's not close. Frequently you'll end up with a hashing strategy of some variety. In any case, just know it's an added layer of complexity and don't adopt it without some forethought.</p>\n<h2 id=\"managed-cloud-version\" style=\"position:relative;\"><a href=\"#managed-cloud-version\" aria-label=\"managed cloud version permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Managed Cloud Version</h2>\n<p>In all honesty, as a developer, it's much easier to just use a managed cloud service like <a href=\"https://www.mongodb.com/cloud/atlas\">MongoDB Atlas</a>, <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-introduction\">Microsoft Azure Cosmos DB</a>, or <a href=\"https://aws.amazon.com/documentdb/\">Amazon Web Services DocumentDB</a>. These services will manage literally everything for you so you can just focus on writing your app. It's what I do every time I go run a production database.</p>","frontmatter":{"path":"/mongodb-ops","title":"MongoDB Ops","order":"2H","section":"NoSQL","description":"While developers don't necessarily need to know how to run a database cluster in production, it can be important to know how and why databases are being run the way they are. Brian gives a brief treatise on the various features of MongoDB's operations aspects."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5D","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}