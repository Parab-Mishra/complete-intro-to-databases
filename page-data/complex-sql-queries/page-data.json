{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/complex-sql-queries",
    "result": {"data":{"markdownRemark":{"html":"<p>Let's get into some more complicated querying. First thing we're going to need is two more tables, comments and boards. We'll be making the data structure for a very simple message board system that has users, comments, and boards. The interesting part here is that every comment is posted by a user and therefore will need to reference the user table, and it will be posted to board and therefore will need to reference a board from the boards table. This is what you would call relational data and where relational databases really shine.</p>\n<h2 id=\"foreign-keys\" style=\"position:relative;\"><a href=\"#foreign-keys\" aria-label=\"foreign keys permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Foreign Keys</h2>\n<p>Let's jot down all of our schemas for our users, boards, and comments.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> users <span class=\"token punctuation\">(</span>\n  user_id <span class=\"token keyword\">INTEGER</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> GENERATED ALWAYS <span class=\"token keyword\">AS</span> <span class=\"token keyword\">IDENTITY</span><span class=\"token punctuation\">,</span>\n  username <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span> <span class=\"token number\">25</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  email <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span> <span class=\"token number\">50</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  full_name <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  last_login <span class=\"token keyword\">TIMESTAMP</span><span class=\"token punctuation\">,</span>\n  created_on <span class=\"token keyword\">TIMESTAMP</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> boards <span class=\"token punctuation\">(</span>\n  board_id <span class=\"token keyword\">INTEGER</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> GENERATED ALWAYS <span class=\"token keyword\">AS</span> <span class=\"token keyword\">IDENTITY</span><span class=\"token punctuation\">,</span>\n  board_name <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span> <span class=\"token number\">50</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  board_description <span class=\"token keyword\">TEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> comments <span class=\"token punctuation\">(</span>\n  comment_id <span class=\"token keyword\">INTEGER</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> GENERATED ALWAYS <span class=\"token keyword\">AS</span> <span class=\"token keyword\">IDENTITY</span><span class=\"token punctuation\">,</span>\n  user_id <span class=\"token keyword\">INT</span> <span class=\"token keyword\">REFERENCES</span> users<span class=\"token punctuation\">(</span>user_id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">CASCADE</span><span class=\"token punctuation\">,</span>\n  board_id <span class=\"token keyword\">INT</span> <span class=\"token keyword\">REFERENCES</span> boards<span class=\"token punctuation\">(</span>board_id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ON</span> <span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">CASCADE</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">comment</span> <span class=\"token keyword\">TEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">time</span> <span class=\"token keyword\">TIMESTAMP</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<ul>\n<li>The first two should look pretty familiar. The only new-ish thing is the user of the <code class=\"language-text\">TEXT</code> data type. This is basically a VARCHAR with no cap (or rather a very large cap.) It has some other small differences but for now just know it's uncapped text.</li>\n<li><code class=\"language-text\">user_id INT REFERENCES users(user_id)</code> is technically all you need to make a foreign key. The first part, <code class=\"language-text\">INT</code>, makes it known that this key will be stored as an integer. It then uses the <code class=\"language-text\">REFERENCES</code> key word to let PostgreSQL know that it is a foreign key. A foreign key is a field in one table that references the <strong>primary</strong> key of another table. In this case, a comment will reference the user_id in another table, the users table. The <code class=\"language-text\">users</code> part say it's reference the users table and the <code class=\"language-text\">(user_id)</code> is the name of the key in the other table. In this case, we called both user_id (which will probably happen somewhat frequently but not always) so they match but if we had called the user_id just id in the users table, we'd put <code class=\"language-text\">id</code> there.</li>\n<li><code class=\"language-text\">ON DELETE CASCADE</code> lets PostgreSQL know what to do if the user gets deleted. So if a user makes a comment on the message board and then deletes their account, what do you want it to do? If you omit the <code class=\"language-text\">ON DELETE CASCADE</code> part, it's the same as doing <code class=\"language-text\">ON DELETE NO ACTION</code> which means it'll just error and not let you delete the user until you've deleted all the comments first. You can also do <code class=\"language-text\">ON DELETE SET NULL</code> which means it'll make the user_id null on any comment that was made by that user.</li>\n<li>We've dne the same for board_id, just referencing the boards table instead of the users table.</li>\n</ul>\n<p>Let's go ahead and put some dummy data in there. Copy / paste [this query] into your psql terminal. It may take a few minutes.</p>\n<h2 id=\"join\" style=\"position:relative;\"><a href=\"#join\" aria-label=\"join permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JOIN</h2>\n<p>So a user goes to your message board and click</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> comment_id<span class=\"token punctuation\">,</span> user_id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> preview <span class=\"token keyword\">FROM</span> comments <span class=\"token keyword\">WHERE</span> board_id <span class=\"token operator\">=</span> <span class=\"token number\">39</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>Two new things here. The <code class=\"language-text\">LEFT</code> function will return the first X characters of a string (as you can guess, RIGHT returns the last X charcters). We'r doing this because this hard to read otherwise in the command line.</li>\n<li>The <code class=\"language-text\">AS</code> keyword lets you rename how the string is projected. If we don't use AS here, the string will be returned under they key <code class=\"language-text\">left</code> which doesn't make sense.</li>\n</ul>\n<p>Okay so you'll get something back like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> comment_id | user_id |       preview\n------------+---------+----------------------\n         63 |     858 | Maecenas tristique,\n        358 |     876 | Mauris enim leo, rho\n        429 |     789 | Maecenas ut massa qu\n        463 |     925 | Phasellus sit amet e\n        485 |     112 | Maecenas tristique,\n        540 |     588 | Nullam porttitor lac\n        545 |     587 | Praesent id massa id\n        972 |     998 | Aenean lectus. Pelle\n(8 rows)</code></pre></div>\n<p>We can't really use this to display the comments on our web app because your users don't care what user_id posted these comments, they want the username. But that doesn't live in the comments table, that exists in the users table. So how do we connect those together?</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  comment_id<span class=\"token punctuation\">,</span> comments<span class=\"token punctuation\">.</span>user_id<span class=\"token punctuation\">,</span> users<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">,</span> <span class=\"token keyword\">time</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> preview\n<span class=\"token keyword\">FROM</span>\n  comments\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span>\n  users\n<span class=\"token keyword\">ON</span>\n  comments<span class=\"token punctuation\">.</span>user_id <span class=\"token operator\">=</span> users<span class=\"token punctuation\">.</span>user_id\n<span class=\"token keyword\">WHERE</span>\n  board_id <span class=\"token operator\">=</span> <span class=\"token number\">39</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Magic! The big key here is the <code class=\"language-text\">INNER JOIN</code> which allows us to match up all the keys from one table to another. We do that in <code class=\"language-text\">ON</code> clause where we say user<em>ids match is where you can _join</em> together those records into one record.</p>\n<p>Let's talk about <code class=\"language-text\">INNER</code> for a second. There are multiple kinds of JOINs. INNER is a good one start with. It says \"find where user_ids match. If you find a record where the user_id exists in one but not in the other, omit it in the results.\" This isn't a particularly useful distinction for us right now becase all user_ids will exist in users and we're assured of that due to the foreign key restraints we used. However if a comment had a user_id that didn't exist, it would omit that comment in the results.</p>\n<p><a href=\"https://commons.wikimedia.org/wiki/File:SQL_Joins.svg\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQElEQVQ4y3XTSYhVRxQG4O8N971ufe0Qh9a21TbO08JpE4wLQ3d04wQu3AQkIE6EIERUdGGD4kZUyEZBdBUX0ZC4EMGNpAlBsnAAt7qIiratPtHb0SZy5VrVk+gPl8Otc+qv/5z6i2Eox9iFKsbji1H4ElPoKLEW3+E6mmJ9wSewIsasQFaMMV8o8stqji2J//01Mb/W59BEdR4mhMIPXynEh79z40hcKwzmtZDMQe0TfO15jwk3Oqj/we2vBhVeXcz5aVEdHuzi5WXO5QIaWVT9iGxlVNONvqO8yeg+PNjiAayL6nK8+jPUpO38PWR9APtxPp7+uIXHW/l1Uph2eSaNc0jmM6Uh1Py1gKcb+CcJF/INDvaTFXEhkr3G/3iOi0Pld2Aj2qJCpHHP/RgPDVXYW6CO+lye7GHzmKCulA97YrCMVjTTNCoQXJ5LfR/3a3HvAFuBmTNQ4cXPpHfDht/K1FbRkPeznuIaki2MXhryZ6byto+uTcGw08f1E1ZozFuZzJXF9Ozg66Z4IbnTR5CMi06vhZjnLs2ivo1l+e1Pp9RquM17or968S8etdCzmldLwsCzhPoyepZzp8pNvDPEkwHHTx0v/fjT3mKWZUrlJ0XqpXBIepM0ozfj3nLSUzw7R/0s/52ORNF/pwcJO4922vnDrv7uKyRTMZb0GOkt0uu8nEjfVrpP8vQE9/ZgDM2tFJNhDjx8pPP77bu3f4uRlWqljeICzA9PsNSMhjDnfJ7XamSNYZblhZgdZzuA9ww8pkGSltTFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"diagram of SQL joins\"\n        title=\"diagram of SQL joins\"\n        src=\"/complete-intro-to-databases/static/a729907d372a71692cc11a04cf37a85b/5a190/SQL_Joins.png\"\n        srcset=\"/complete-intro-to-databases/static/a729907d372a71692cc11a04cf37a85b/772e8/SQL_Joins.png 200w,\n/complete-intro-to-databases/static/a729907d372a71692cc11a04cf37a85b/e17e5/SQL_Joins.png 400w,\n/complete-intro-to-databases/static/a729907d372a71692cc11a04cf37a85b/5a190/SQL_Joins.png 800w,\n/complete-intro-to-databases/static/a729907d372a71692cc11a04cf37a85b/00d43/SQL_Joins.png 1000w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></a></p>\n<p>A <code class=\"language-text\">LEFT JOIN</code> would say \"if a comment has a user_id that doesn't exist, include it anyway.\" A <code class=\"language-text\">RIGHT JOIN</code> wouldn't make much sense here but it would include users even if they didn't have a comment on that board.</p>\n<p>We can also an <code class=\"language-text\">OUTER JOIN</code> which would be everything that <em>doesn't match</em>. In our database, that would be nothing because we're guaranteed everything has match due to our constraints.</p>\n<p>You can also do a <code class=\"language-text\">FULL OUTER JOIN</code> which says just include everything. If it doesn't have a match from either side, include it. If it does have a match, include it.</p>\n<p>Another rarely useful join is the <code class=\"language-text\">CROSS JOIN</code>. This gives the <em>Cartesian product</em> of the two tables which can be enormous. A Cartesian product would be every row matched with every other row in the other table. If you have A, B, and C in one table with D and E in the other, your CROSS JOIN would be AD, AE, BD, BE, CD, an CE. If you do a cross join between two tables with 1,000 rows each, you'd get 1,000,000 records back.</p>\n<p>Tables can also be self-joined. Imagine you have a table of employees and one of the fields is direct_reports which contains employee_ids of employees that report the original employee. You could do a SELF JOIN to get the information for the reports.</p>\n<p>Honestly 95% of what I do is covered by INNER and LEFT joins.</p>\n<p>One neat trick we could do here is a NATURAL JOIN.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  comment_id<span class=\"token punctuation\">,</span> comments<span class=\"token punctuation\">.</span>user_id<span class=\"token punctuation\">,</span> users<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">,</span> <span class=\"token keyword\">time</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> preview\n<span class=\"token keyword\">FROM</span>\n  comments\n<span class=\"token keyword\">NATURAL</span> <span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span>\n  users\n<span class=\"token keyword\">WHERE</span>\n  board_id <span class=\"token operator\">=</span> <span class=\"token number\">39</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This will work like it did above. NATURAL JOIN tells PostgreSQL \"I named things the same in both tables, go ahead and match it together yourself. This is fun when it lines up but I don't often end up using it myself. And in the end it's often better to be explicit what about your intent is for joins. So use cautiously and/or for neat party tricks.</p>\n<h2 id=\"subqueries\" style=\"position:relative;\"><a href=\"#subqueries\" aria-label=\"subqueries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Subqueries</h2>\n<p>Let's say you need to find all the comments made by Maynord Simonich. You could make two queries: query for Kate's user_id from users, and then use that user_id to query comments. Or we could do it all at once with a subquery!</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> comment_id<span class=\"token punctuation\">,</span> user_id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">LEFT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">comment</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> comments <span class=\"token keyword\">WHERE</span> user_id <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> user_id <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> full_name <span class=\"token operator\">=</span> <span class=\"token string\">'Maynord Simonich'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This will query for Maynord's ID and immediately use that in the other query. Make sure this returns exactly one row or this will fail. You can use subqueries in a variety of ways but it generally looks like this with <code class=\"language-text\">()</code> surrounding the subqueries. You can even have subqueries in your subqueries!</p>\n<h2 id=\"group-by\" style=\"position:relative;\"><a href=\"#group-by\" aria-label=\"group by permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GROUP BY</h2>\n<p>What if you were making a report and you wanted to show the top ten most posted-to message boards? You could run something like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  boards<span class=\"token punctuation\">.</span>board_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> comment_count\n<span class=\"token keyword\">FROM</span>\n  comments\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span>\n  boards\n<span class=\"token keyword\">ON</span>\n  boards<span class=\"token punctuation\">.</span>board_id <span class=\"token operator\">=</span> comments<span class=\"token punctuation\">.</span>board_id\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span>\n  boards<span class=\"token punctuation\">.</span>board_name\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span>\n  comment_count <span class=\"token keyword\">DESC</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">GROUP BY</code> is going to collapse all the same board_names (guaranteed unique due to our UNIQUE constraint on the board) and then we use the <code class=\"language-text\">COUNT(*)</code> to count how many boards have that same <code class=\"language-text\">board_name</code>. So this works! This will give us the precise number of comments on the top board!</p>\n<p>Now what if you wanted to see the boards that were the least populated? We could just flip the <code class=\"language-text\">ORDER BY</code> to <code class=\"language-text\">ASC</code> but there's a distinct problem here: what happens if there's no post on a board?</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  boards<span class=\"token punctuation\">.</span>board_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> comment_count\n<span class=\"token keyword\">FROM</span>\n  comments\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span>\n  boards\n<span class=\"token keyword\">ON</span>\n  boards<span class=\"token punctuation\">.</span>board_id <span class=\"token operator\">=</span> comments<span class=\"token punctuation\">.</span>board_id\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span>\n  boards<span class=\"token punctuation\">.</span>board_name\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span>\n  comment_count <span class=\"token keyword\">ASC</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>It wouldn't show up because of the <code class=\"language-text\">INNER JOIN</code>. So what do we need? Well, the \"LEFT\" board here is the comments (the one that's in the FROM will be LEFT) and we don't need anything more from the comments board since all of them will show up in the query thanks to the foreign key constraints. So then we need a RIGHT JOIN! We need to include boards that don't have any comments. We also need to change <code class=\"language-text\">COUNT(*)</code> because any row counts for a <code class=\"language-text\">*</code> and that would make it look like there was one comment on our empty boards when in reality there was zero. We need therefore it to be <code class=\"language-text\">COUNT(comment_id)</code> because that will actually count how many comments exist.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n  boards<span class=\"token punctuation\">.</span>board_name<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>comment_id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> comment_count\n<span class=\"token keyword\">FROM</span>\n  comments\n<span class=\"token keyword\">RIGHT</span> <span class=\"token keyword\">JOIN</span>\n  boards\n<span class=\"token keyword\">ON</span>\n  boards<span class=\"token punctuation\">.</span>board_id <span class=\"token operator\">=</span> comments<span class=\"token punctuation\">.</span>board_id\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span>\n  boards<span class=\"token punctuation\">.</span>board_name\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span>\n  comment_count<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Tricky! It's important to know your data, what you expect to see, and be aware of the constraints of your queries!</p>","frontmatter":{"path":"/complex-sql-queries","title":"Complex SQL Queries","order":"3D","section":"SQL","description":"Brian dives into how to compound queries, joins, unions, group bys, and other ways to get obtain powerful results with the expressiveness of SQL"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5D","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}