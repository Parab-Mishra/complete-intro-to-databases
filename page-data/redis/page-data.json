{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/redis",
    "result": {"data":{"markdownRemark":{"html":"<p>Let's get Redis running through Docker. Run this</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -dit --rm --name<span class=\"token operator\">=</span>my-redis -p <span class=\"token number\">6379</span>:6379 redis:6.0.8\n<span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> -it my-redis redis-cli</code></pre></div>\n<p>This should drop you into an interactive shell with Redis. Let's start with some basic sets and gets.</p>\n<h2 id=\"set-and-get\" style=\"position:relative;\"><a href=\"#set-and-get\" aria-label=\"set and get permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SET and GET</h2>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET name &quot;Brian Holt&quot;\nGET name</code></pre></div>\n<p>There ya go. That's it. Pack it up. Go home. We're done here.</p>\n<p>I mean, just kidding, but pretty close. Redis commands are almost very simple like this. You send a command (e.g. <code class=\"language-text\">GET</code> and <code class=\"language-text\">SET</code>), a key (e.g. <code class=\"language-text\">name</code>) and a value (e.g. the string <code class=\"language-text\">\"Brian Holt\"</code>.)</p>\n<h2 id=\"naming-keys\" style=\"position:relative;\"><a href=\"#naming-keys\" aria-label=\"naming keys permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Naming Keys</h2>\n<p>Let's talk a second about naming keys. It's not sustainable to just a flat name like <code class=\"language-text\">name</code>. Unlike PostgreSQL and MongoDB where you have tables and collections to logically separate entities, with Redis it's all one mishmosh of stuff. Only the keys separate what's in there. So that means you need some sort of key system to keep things separate yet retrievable.</p>\n<p>Let's say you cache user information. The most commons strategy is to use <code class=\"language-text\">:</code> to separate and \"namespace\" keys. So if you had three users named <code class=\"language-text\">btholt</code>, <code class=\"language-text\">sarah_edo</code> and <code class=\"language-text\">scotups</code>, you may store their user info in three different keys like this: <code class=\"language-text\">user:sarah_edo</code>, <code class=\"language-text\">user:btholt</code>, and <code class=\"language-text\">user:scotups</code>. Now we know we can always retrieve <code class=\"language-text\">user:&lt;user name here></code> whenever we want user info. We also don't have to worry that if we cache payments later that we'll overwrite the <code class=\"language-text\">scotups</code> key, we can just namespace it different like <code class=\"language-text\">payment:scotups</code>, <code class=\"language-text\">payment:1marc</code>, etc. You can even go further and have multiple layers like <code class=\"language-text\">user:address:btholt</code>. These keys can actually be up to 512MB in length (don't do that haha) so you can have very long key names. Again, Redis just see this as a key so it's up to us how we want to namespace it. Redis won't enforce anything about it.</p>\n<p>While I see <code class=\"language-text\">:</code> mostly as the delimiter, you'll see some use <code class=\"language-text\">/</code> too.</p>\n<p>Technically Redis keys are \"binary safe\" which means you could have a JPEG (like the actual image itself) as a key. In general I wouldn't using a binary like that directly since the key will be long and the key comparison it will do will slow down Redis but you could MD5 an image and use that as a key if you were using Redis to disallow-list images or something like that.</p>\n<h2 id=\"incr-decr-incrby-decrby\" style=\"position:relative;\"><a href=\"#incr-decr-incrby-decrby\" aria-label=\"incr decr incrby decrby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INCR DECR INCRBY DECRBY</h2>\n<p>A very common thing is wanting to do is do some quick additions or substracts on a value in the store. One of them could be that you're tracking page views. You could do something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET visits 0\nINCR visits\nINCR visits\nINCR visits\nDECR visits</code></pre></div>\n<p>Every time a user hits your website, you could just send a quick command to Redis to increment its store. You don't need to know right then what the count of visits is. It's enough to blindly fire off \"whatever is there, add 1\". I added a <code class=\"language-text\">DECR</code> at the end just so you can see how to decrement too.</p>\n<p>What if you need to add or subtract more than just one? One case could be that you're tracking someone's score in a (American) football game and one team scores a touchdown. You could do:</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET scor\nINCRBY score:seahawks 6\nDECRBY score:broncos 3</code></pre></div>\n<p>Same idea, you just have to tell Redis by how much you want to add or subtract.</p>\n<h2 id=\"mset-mget\" style=\"position:relative;\"><a href=\"#mset-mget\" aria-label=\"mset mget permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSET MGET</h2>\n<p>Another thing you can do is do multiple gets at a time as well as multipe sets</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">MSET score:seahawks 43 score:broncos 8\nMGET score:seahawks score:broncos</code></pre></div>\n<p>You can have a lot of keys here so this is useful if you need to write or get a lot of things at once.</p>\n<p>There is also [pipelines][pipelines] as well as [transactions][transactions] available to you as well if you need to batch write things. That's beyond the scope of this intro but just be aware all of these are helpers for doing multiple things at once.</p>\n<h2 id=\"exists\" style=\"position:relative;\"><a href=\"#exists\" aria-label=\"exists permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EXISTS</h2>\n<p>This is very helpful for making sure you don't duplicate anything. If you're write code you're write a code that needs to explore a maze and you want to make sure you don't revisit points on a cartesian plane. You could do something like</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET plane:0:0 visited\nEXISTS plane:1:0\nSET plane:1:0 visited\nEXISTS plane:0:0\nEXISTS plane:1:1\nSET plane:1:1 visited</code></pre></div>\n<p>So it would check each spot on the graph if it had been there, if it had, it would try the next area until it could find somewhere it hadn't been there before. EXISTS will just give you a true or false if a key exists.</p>\n<h2 id=\"del\" style=\"position:relative;\"><a href=\"#del\" aria-label=\"del permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DEL</h2>\n<p>Sometimes you need to explictly need to delete something from the cache.</p>\n<div class=\"gatsby-highlight\" data-language=\"redis\"><pre class=\"language-redis\"><code class=\"language-redis\">SET greeting hello\nEXISTS greeting\nDEL greeting\nEXISTS greeting</code></pre></div>","frontmatter":{"path":"/redis","title":"Redis","order":"5B","section":"Key-Value Store","description":"Graph databases are great when you need to define relations between objects that can have complex webs of relations especially for things like social networks."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"2F","path":"/aggregation","title":"Aggregation"}}},{"node":{"frontmatter":{"order":"4D","path":"/complex-neo4j-queries","title":"Complex Neo4j Queries"}}},{"node":{"frontmatter":{"order":"3D","path":"/complex-sql-queries","title":"Complex SQL Queries"}}},{"node":{"frontmatter":{"order":"4A","path":"/graph-databases","title":"Graph Databases"}}},{"node":{"frontmatter":{"order":"3H","path":"/hasura","title":"Hasura"}}},{"node":{"frontmatter":{"order":"6A","path":"/conclusion","title":"Conclusion"}}},{"node":{"frontmatter":{"order":"2E","path":"/indexes-in-mongodb","title":"Indexes in MongoDB"}}},{"node":{"frontmatter":{"order":"1B","path":"/installation-notes","title":"Installation Notes"}}},{"node":{"frontmatter":{"order":"3A","path":"/intro-to-sql-databases","title":"Intro to SQL Database"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"3E","path":"/json-in-postgresql","title":"JSON in PostgreSQL"}}},{"node":{"frontmatter":{"order":"2H","path":"/mongodb-ops","title":"MongoDB Ops"}}},{"node":{"frontmatter":{"order":"5A","path":"/key-value-store","title":"Key-Value Store"}}},{"node":{"frontmatter":{"order":"2B","path":"/mongodb","title":"MongoDB"}}},{"node":{"frontmatter":{"order":"5E","path":"/more-redis-concepts","title":"More Redis Concepts"}}},{"node":{"frontmatter":{"order":"4C","path":"/neo4j-browser","title":"Neo4j Browser"}}},{"node":{"frontmatter":{"order":"4E","path":"/neo4j-indexes","title":"Indexes in Neo4j"}}},{"node":{"frontmatter":{"order":"4G","path":"/neo4j-ops","title":"Neo4j Ops"}}},{"node":{"frontmatter":{"order":"4B","path":"/neo4j","title":"Neo4j"}}},{"node":{"frontmatter":{"order":"4F","path":"/nodejs-app-with-neo4j","title":"Node.js App with Neo4j"}}},{"node":{"frontmatter":{"order":"3G","path":"/nodejs-app-with-postgresql","title":"Node.js App with PostgreSQL"}}},{"node":{"frontmatter":{"order":"5F","path":"/nodejs-app-with-redis","title":"Node.js App with Redis"}}},{"node":{"frontmatter":{"order":"2G","path":"/nodejs-app-with-mongodb","title":"Write a Node.js app with MongoDB"}}},{"node":{"frontmatter":{"order":"2A","path":"/nosql","title":"NoSQL"}}},{"node":{"frontmatter":{"order":"3F","path":"/postgresql-indexes","title":"Indexes in PostgreSQL"}}},{"node":{"frontmatter":{"order":"3I","path":"/postgresql-ops","title":"PostgreSQL Ops"}}},{"node":{"frontmatter":{"order":"3B","path":"/postgresql","title":"PostgreSQL"}}},{"node":{"frontmatter":{"order":"2C","path":"/querying-mongodb","title":"Querying MongoDB"}}},{"node":{"frontmatter":{"order":"3C","path":"/querying-postgresql","title":"Querying PostgreSQL"}}},{"node":{"frontmatter":{"order":"5C","path":"/redis-command-options","title":"Redis Command Options"}}},{"node":{"frontmatter":{"order":"5G","path":"/redis-ops","title":"Redis Ops"}}},{"node":{"frontmatter":{"order":"5D","path":"/redis-data-types","title":"Redis Data Types"}}},{"node":{"frontmatter":{"order":"5B","path":"/redis","title":"Redis"}}},{"node":{"frontmatter":{"order":"1C","path":"/terminology","title":"Terminology"}}},{"node":{"frontmatter":{"order":"2D","path":"/updating-mongodb","title":"Updating MongoDB"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}